/*
 * Bullet Ledger
 * Copyright (C) 2025 Joshua Olson
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

use std::fs::OpenOptions;
use std::io::{self, Read, Seek, SeekFrom, Write};

use curve25519_dalek::constants::X25519_BASEPOINT;
use curve25519_dalek::montgomery::MontgomeryPoint;
use curve25519_dalek::scalar::Scalar;
use zeroize::Zeroize;

use hkdf::Hkdf;
use sha2::Sha256;


/// RFC7748 clamping for X25519 private scalar (little-endian bytes)
fn clamp_scalar_bytes(mut sk: [u8; 32]) -> [u8; 32] {
    sk[0] &= 248;
    sk[31] &= 127;
    sk[31] |= 64;
    sk
}

/// Generate a new X25519 keypair (private bytes, public bytes)
pub fn generate_keypair() -> ([u8; 32], [u8; 32]) {
    let mut raw = super::random::random_b32();

    let priv_bytes = clamp_scalar_bytes(raw);

    // Construct scalar with the specific bit pattern (no mod-l reduction)
    let scalar = Scalar::from_bytes_mod_order(priv_bytes);

    // Multiply basepoint by scalar (Montgomery ladder)
    let pub_point: MontgomeryPoint = &X25519_BASEPOINT * &scalar;
    let pub_bytes = pub_point.to_bytes();

    // zeroize scalar-related sensitive data (we have to explicitly zero raw if desired)
    // Note: Scalar does not implement Zeroize, but our raw array is zeroized below (if we kept it).
    // We will return priv_bytes, but if you keep it in memory longer, ensure secure storage.
    raw.zeroize();

    (pub_bytes, priv_bytes)
}

/// Compute ECDH shared coordinate: returns 32 bytes (u-coordinate)
/// `priv_bytes` must be the 32-byte clamped scalar (as generated by generate_keypair).
/// `peer_pub_bytes` is the peer's 32-byte X25519 public key.
pub fn ecdh_shared_secret(priv_bytes: [u8; 32], peer_pub_bytes: [u8; 32]) -> [u8; 32] {
    // Build scalar with the exact bit pattern expected by X25519
    let scalar = Scalar::from_bytes_mod_order(priv_bytes);

    // Peer public -> MontgomeryPoint
    let peer_point = MontgomeryPoint(peer_pub_bytes);

    // Scalar multiplication: u = [scalar] peer_point
    let shared_point: MontgomeryPoint = &peer_point * &scalar;

    // shared u-coordinate as bytes
    shared_point.to_bytes()
}

/// Example: derive a 32-byte symmetric key from the raw shared secret using HKDF-SHA256
pub fn hkdf_derive_key(shared_secret: &[u8; 32], info: &[u8], salt: [u8;32]) -> [u8; 32] {
    // Use a zero or application-specific salt (prefer non-zero salt in real systems).
    let hk = Hkdf::<Sha256>::new(Some(&salt), shared_secret);
    let mut okm = [0u8; 32];
    hk.expand(info, &mut okm).expect("HKDF expand should not fail");
    okm
}


pub fn load_keys(key_path: &str) -> io::Result<([u8; 32], [u8; 32])> {
    let mut file = OpenOptions::new()
        .read(true)
        .write(true)
        .create(true)
        .open(key_path)?;

    let mut pub_key = [0u8; 32];
    let mut priv_key = [0u8; 32];

    // Try reading both keys completely
    let result = file.read_exact(&mut pub_key)
        .and_then(|_| file.read_exact(&mut priv_key));

    if result.is_err() {
        // Rewind to start before writing new keys
        file.set_len(0)?;               // clear file
        file.seek(SeekFrom::Start(0))?;

        // Generate new keypair
        let (new_pub, new_priv) = generate_keypair();
        file.write_all(&new_pub)?;
        file.write_all(&new_priv)?;
        file.flush()?;

        Ok((new_pub, new_priv))
    } else {
        Ok((pub_key, priv_key))
    }
}
